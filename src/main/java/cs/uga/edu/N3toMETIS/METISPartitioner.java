package cs.uga.edu.N3toMETIS;

import gnu.trove.list.array.TShortArrayList;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;

import cs.uga.edu.util.Util;

public class METISPartitioner {

	private static boolean useDirectHops = true;		//Using directed hop (DEFAULT)
	private static boolean useHashPartitioning = false;
	private static Integer numPartitions = 2;
	private static String partfile;
	private static String nodemap;
	 




	public static void main(String[] args) {

		// Let's go through the user input and pars the flags.
		if(args.length == 0)
		{
			usage();
			System.exit(0);
		}
		
		for (int i = 0; i < args.length; i++) {
			//Directed Hop?
			if(args[i].equalsIgnoreCase("-d") || args[i].equalsIgnoreCase("--directed") )
			{
				useDirectHops  = true; 
			}
			else if (args[i].equalsIgnoreCase("-u") || args[i].equalsIgnoreCase("--undirected"))
			{
				useDirectHops = false;
			}
			else if (args[i].equalsIgnoreCase("-p") || args[i].equalsIgnoreCase("--hash"))
			{
				useHashPartitioning  = true;
				if (args.length < i + 4)
				{
					usage();
					System.exit(1);
				}

				//Number of partitions is the next param 
				numPartitions  = Integer.valueOf(args[++i]);
			}
			else if (args[i].equalsIgnoreCase("-g") || args[i].equalsIgnoreCase("--graph"))
			{
				useHashPartitioning = false;
				if (args.length < i + 4)
				{
					usage();
					System.exit(1);
				}

				partfile = args[++i]; 
			}
			else if (args[i].equalsIgnoreCase("-nm") || args[i].equalsIgnoreCase("--nodemap"))
			{
				if (args.length < i + 2)
				{
					usage();
					System.exit(1);
				}

				nodemap = args[++i]; 
			}
//			else if (args[i].equalsIgnoreCase("-h") || args[i].equalsIgnoreCase("--hops"))
//			{
//				if (args.length < i + 4)
//				{
//					usage();
//					System.exit(1);
//				}
//
//				hops = Integer.valueOf(args[++i]);
//			}
			else
			{
				//nodecnt = Integer.valueOf(args[i]);

				partition(Arrays.copyOfRange(args, i, args.length));
				break;
			}		
		}
	}





	private static void partition(String[] args) {
		
		final TShortArrayList part = new TShortArrayList(); 
		
		//Finding max number of partition and the partition for each node. 
		if(!useHashPartitioning)
		{
			int maxPartition = 0; 
			
			try(final BufferedReader bufRead = new BufferedReader( new FileReader(partfile)))
			{
				String line =  null ; 
				while ((line = bufRead.readLine()) != null)
				{
					short p = Short.valueOf(line); 
					if (p > maxPartition)
					{
						maxPartition = p;
					}
					part.add(p); 
				}
			} catch (IOException e) {
				System.err.println("cannot read from " + partfile + ".");
				e.printStackTrace();
				System.exit(1);
			}
			numPartitions = maxPartition + 1;
		}
		
		// read the mapping for Subject hash --> Number from file
		try {
		
			Util.readSerializedNodeMap(new File(nodemap));
		
		} catch (ClassNotFoundException | IOException e) {
			System.err.println("cannot read from " + nodemap + ".");
			e.printStackTrace();
			System.exit(1);
		} 
		
		
		
		
		
		
		
	}





	/**************************************************************************
	 * Notes: 
	 * graph file: is the partition representation of the graph. i.e which cluster each node(entity) is 
	 * assigned to. 
	 * 
	 * nodeCount: number of entities (nodes) in the graph
	 */
	private static void usage() {

		System.out.println("usage: "
				+ METISPartitioner.class.getName()
				+ " (-p p | -g file) [-d | -u] [-nm file] file1.n3 [file2.n3 ...]");
		System.out.println("available options:\n==================");
		System.out.println(" -p, --hash p     : use hash partitioning on subject and create p partitions");
		System.out.println(" -g, --graph file : use graph-based partitioning stored in file (Partition file generated by METIS)");
		System.out.println(" -d, --directed   : directed hops (default)");
		System.out.println(" -u, --undirected : undirected hops (untested)");
		System.out.println(" -nm, --nodemap file: read node map produced by  Metisloader");
		//System.out.println(" -h, --hops h     : use h hops ");
		//System.out.println(" -l, --literals   : graph includes literals (experimental)");
		System.out.println(" --help           : print this help and exit");
	}







}
