/**
 * @author Arsham
 * date: 5/12/2014
 * The purpose of this class is to read the nt file generated by the preprocess.sh script
 * and partition the Triples according to the number of partitions requested by the user.
 *
 */


package cs.uga.edu.Graph;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Partitioner {
	
	private static int 	   numPartitions 		= 3;
	private static boolean useHashPartitioning  = true;
	
	
	private static final boolean DEBUG = true ;

	public static Set<String> findDistinctPredicates(String[] args)
	{
		Set<String> predSet = new HashSet<>(); 

		for(int i = 0 ; i < args.length; i++)
		{
			Path path = Paths.get(args[i]); 
			try (BufferedReader reader = Files.newBufferedReader(path , StandardCharsets.UTF_8)){
				String line = null;
				while ((line = reader.readLine()) != null) 
				{

					String pred = line.substring(0, line.length() - 1).trim().split("\\s+")[1]; 

					// Predicate has to be a URI  
					if(pred.startsWith("<") && pred.endsWith(">"))
					{
						pred = pred.substring(1, pred.length() - 1); 
						if(DEBUG)
							System.out.println(pred);

						if(!predSet.contains(pred))
							predSet.add(pred); 
					}
					else
					{
						System.err.println("[" + path + "] invalid predicate \n " + line + ", skip.");
						continue;
					}
				}
			}catch (IOException e) {
				System.err.println("ERROR: Failed to read the file " + path);
				e.printStackTrace();
			}
		}
		return predSet; 
	}
	
	/**************************************************************************
	 * @param args
	 */
	public static void partition(String[] args)
	{
		// Getting ready to write triples to each partition file.
		final PrintWriter files[]=new PrintWriter[numPartitions];
		try
		{
			for (int i = 0; i < numPartitions; i++)
				files[i] = new PrintWriter(new File("part"+i+".n3"),"UTF-8");	
		}
		catch(Exception e)
		{
			System.err.println("cannot open output files.");
			e.printStackTrace();
			System.exit(2);
		}
		
		// Let's read the file
		for(int i = 0 ; i < args.length; i++)
		{
			Path path = Paths.get(args[i]); 
			try (BufferedReader reader = Files.newBufferedReader(path , StandardCharsets.UTF_8)){
				String line = null;
				
				
										
					if(!useHashPartitioning)
					{
						/*
						 * reading the document once and create an array list with line numbers for when predicates
						 * change in the file. 
						 */
						int lineNum = 1;
						List<Integer> predLns = new ArrayList<Integer>(); 
						String curntPred = null; 
						while ((line = reader.readLine()) != null) {
							
							String pred = line.substring(0, line.length() - 1).trim().split("\\s+")[1]; 
							if(curntPred == null || !curntPred.equalsIgnoreCase( pred))
							{
								curntPred =  pred; 
								predLns.add(lineNum++); 
							}
							else
							{
								lineNum++; 
							}
						}//end while
						
						if(DEBUG)
						{
							for(int lns : predLns)
							{
								System.out.print(lns + ",");
							}
						}
					}
					else
					{
						while ((line = reader.readLine()) != null) 
						{
							// Let's read the file and distribute the triples based on pred hash.
							String pred = line.substring(0, line.length() - 1).trim().split("\\s+")[1]; 
							if(pred.startsWith("<") && pred.endsWith(">"))
							{
								int partition = (Math.abs(pred.substring(1, pred.length() - 1).hashCode()) % numPartitions);
								emit(files[partition],line);

								if(DEBUG)
								{
									System.out.println(partition + ": " + line);
								}
							}
							else
							{
								System.err.println("Invalid predicate \n " + line + ", skip.");
								continue;
							}
						}//end while
					}//end else
				
			} catch (IOException e) {
				System.err.println("ERROR: Failed to read the file " + path);
				e.printStackTrace();
			}
			
		}
	}

	
	/**************************************************************************
	 * Notes: 
	 * graph file: is the partition representation of the graph. i.e which cluster each node(entity) is 
	 * assigned to. 
	 * 
	 * nodeCount: number of entities (nodes) in the graph
	 */
	private static void usage() {

		System.out.println("usage: "
				+ Partitioner.class.getName()
				+ " (-hp p | -op p)  file1.n3 [file2.n3 ...]");
		System.out.println("available options:\n==================");
		System.out.println(" -hp, --hash p     : use hash partitioning on predicate and create p partitions");
		System.out.println(" -op, --own p      : use our custom partitioning and create p partitions");
		System.out.println(" -h, --help        : print this help and exit");
	}
	
	
	
	/***************************************************************************
	 * @param pw
	 * @param line
	 */
	private static void emit(PrintWriter pw, String line) {
		pw.println(line); 
	}


	public static void main(String[] args) {
		
//		if (args.length < 3)
//		{
//			usage();
//			System.exit(1);
//		}
//		
//		for (int i = 0; i < args.length; i++) {
//			
//			if(args[i].equalsIgnoreCase("-hp") || args[i].equalsIgnoreCase("--hash") )
//			{
//				useHashPartitioning = true; 
//
//				if (args.length<i+2)
//				{
//					usage();
//					System.exit(1);
//				}
//
//				numPartitions = Integer.valueOf(args[++i]);
//			}
//			else if(args[i].equalsIgnoreCase("-op") || args[i].equalsIgnoreCase("--own") )
//			{
//				useHashPartitioning = false; 
//
//				if (args.length<i+2)
//				{
//					usage();
//					System.exit(1);
//				}
//
//				numPartitions = Integer.valueOf(args[++i]);
//			}
//			else if (args[i].startsWith("-"))
//			{
//				usage();
//				System.exit(1);
//			}
//			else
//			{
//				System.out.println("--------------------------------------------------------");
//				//String s[] = {"University1_1.Short.SR.PREP.nt"}; 
//				for(String str :findDistinctPredicates(Arrays.copyOfRange(args, i, args.length)).toArray(new String[0]))
//				{
//					System.out.println(str + " p = " + Math.abs(str.hashCode())%numPartitions);
//					
//				}
//				
//				partition(Arrays.copyOfRange(args, i, args.length));
//			}			
//		}
		
		
		
		
		
		
		
		
		
	}





}
